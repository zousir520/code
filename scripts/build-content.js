#!/usr/bin/env node

import { readdir, readFile, writeFile, mkdir } from 'fs/promises';
import { join, dirname, extname, basename } from 'path';
import { fileURLToPath } from 'url';
import matter from 'gray-matter';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT_DIR = join(__dirname, '..');
const CONTENT_DIR = join(ROOT_DIR, 'src/content');
const OUTPUT_DIR = join(ROOT_DIR, 'src/lib/generated');

/**
 * é€’å½’è¯»å–ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶
 */
async function getAllFiles(dir, files = []) {
	const dirFiles = await readdir(dir, { withFileTypes: true });
	
	for (const file of dirFiles) {
		const fullPath = join(dir, file.name);
		if (file.isDirectory()) {
			await getAllFiles(fullPath, files);
		} else {
			files.push(fullPath);
		}
	}
	
	return files;
}

/**
 * å¤„ç† JSON æ–‡ä»¶
 */
async function processJsonFile(filePath) {
	const content = await readFile(filePath, 'utf-8');
	return JSON.parse(content);
}

/**
 * å¤„ç† Markdown æ–‡ä»¶
 */
async function processMarkdownFile(filePath) {
	const content = await readFile(filePath, 'utf-8');
	const { data, content: markdownContent } = matter(content);
	
	return {
		frontmatter: data,
		content: markdownContent,
		slug: basename(filePath, '.md')
	};
}

/**
 * è·å–ç›¸å¯¹äº content ç›®å½•çš„è·¯å¾„
 */
function getRelativePath(filePath) {
	return filePath.replace(CONTENT_DIR, '').replace(/^\//, '');
}

/**
 * å°†è·¯å¾„è½¬æ¢ä¸ºæœ‰æ•ˆçš„ JavaScript æ ‡è¯†ç¬¦
 */
function pathToIdentifier(path) {
	return path
		.replace(/[\/\-\.]/g, '_')
		.replace(/[^a-zA-Z0-9_]/g, '')
		.replace(/^(\d)/, '_$1');
}

/**
 * ä¸»æ„å»ºå‡½æ•°
 */
async function buildContent() {
	console.log('ğŸ”„ å¼€å§‹æ„å»ºå†…å®¹...');
	
	// ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
	await mkdir(OUTPUT_DIR, { recursive: true });
	
	// è·å–æ‰€æœ‰å†…å®¹æ–‡ä»¶
	const allFiles = await getAllFiles(CONTENT_DIR);
	
	const contentMap = {};
	const exports = [];
	
	for (const filePath of allFiles) {
		const relativePath = getRelativePath(filePath);
		const ext = extname(filePath);
		const identifier = pathToIdentifier(relativePath);
		
		console.log(`ğŸ“„ å¤„ç†æ–‡ä»¶: ${relativePath}`);
		
		try {
			let data;
			
			if (ext === '.json') {
				data = await processJsonFile(filePath);
			} else if (ext === '.md') {
				data = await processMarkdownFile(filePath);
			} else {
				// å…¶ä»–æ–‡ä»¶ç±»å‹ï¼Œè¯»å–ä¸ºæ–‡æœ¬
				data = await readFile(filePath, 'utf-8');
			}
			
			contentMap[relativePath] = data;
			exports.push(`export const ${identifier} = ${JSON.stringify(data, null, 2)};`);
			
		} catch (error) {
			console.error(`âŒ å¤„ç†æ–‡ä»¶å¤±è´¥ ${relativePath}:`, error.message);
		}
	}
	
	// ç”Ÿæˆå†…å®¹æ˜ å°„
	const contentMapExport = `export const CONTENT_MAP = ${JSON.stringify(contentMap, null, 2)};`;
	
	// ç”Ÿæˆç±»å‹å®šä¹‰
	const typeDefinitions = `
export interface ContentItem {
	[key: string]: any;
}

export interface BlogPost {
	frontmatter: {
		title: string;
		description?: string;
		date?: string;
		tags?: string[];
		[key: string]: any;
	};
	content: string;
	slug: string;
}

export interface ContentMap {
	[path: string]: ContentItem | BlogPost | string;
}
`;

	// ç”Ÿæˆè·å–å†…å®¹çš„è¾…åŠ©å‡½æ•°
	const helperFunctions = `
/**
 * è·å–å†…å®¹é¡¹
 */
export function getContent(path: string): ContentItem | null {
	return CONTENT_MAP[path] || null;
}

/**
 * è·å–æ‰€æœ‰åšå®¢æ–‡ç« 
 */
export function getAllBlogPosts(locale = 'en'): BlogPost[] {
	const posts: BlogPost[] = [];
	
	for (const [path, content] of Object.entries(CONTENT_MAP)) {
		if (path.startsWith('blog/') && path.endsWith('.md')) {
			const post = content as BlogPost;
			if (!locale || path.includes(\`.\${locale}.md\`) || (!path.includes('.zh.md') && locale === 'en')) {
				posts.push(post);
			}
		}
	}
	
	return posts.sort((a, b) => {
		const dateA = new Date(a.frontmatter.date || 0);
		const dateB = new Date(b.frontmatter.date || 0);
		return dateB.getTime() - dateA.getTime();
	});
}

/**
 * é€šè¿‡ slug è·å–åšå®¢æ–‡ç« 
 */
export function getBlogPostBySlug(slug: string, locale = 'en'): BlogPost | null {
	const posts = getAllBlogPosts(locale);
	return posts.find(post => post.slug === slug || post.slug === \`\${slug}.\${locale}\`) || null;
}

/**
 * è·å–é¡µé¢å†…å®¹
 */
export function getPageContent(slug: string, locale = 'en'): any | null {
	const localizedPath = \`pages/\${slug}.\${locale}.md\`;
	const defaultPath = \`pages/\${slug}.md\`;
	
	return getContent(localizedPath) || getContent(defaultPath);
}

/**
 * è·å–è®¾ç½®å†…å®¹
 */
export function getSettings(type: string): any | null {
	return getContent(\`settings/\${type}.json\`);
}

/**
 * è·å–ä¸»é¡µå†…å®¹
 */
export function getHomeContent(section: string): any | null {
	return getContent(\`home/\${section}.json\`);
}
`;

	// ç”Ÿæˆå®Œæ•´çš„è¾“å‡ºæ–‡ä»¶
	const output = [
		'// è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶ï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘',
		'// Generated by scripts/build-content.js',
		'',
		typeDefinitions,
		contentMapExport,
		'',
		...exports,
		'',
		helperFunctions
	].join('\n');
	
	// å†™å…¥æ–‡ä»¶
	const outputPath = join(OUTPUT_DIR, 'content.ts');
	await writeFile(outputPath, output, 'utf-8');
	
	console.log(`âœ… å†…å®¹æ„å»ºå®Œæˆï¼ç”Ÿæˆäº† ${Object.keys(contentMap).length} ä¸ªå†…å®¹é¡¹`);
	console.log(`ğŸ“ è¾“å‡ºæ–‡ä»¶: ${outputPath}`);
}

// è¿è¡Œæ„å»º
buildContent().catch(console.error);